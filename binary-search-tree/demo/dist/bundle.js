!function(g){var I={};function e(C){if(I[C])return I[C].exports;var A=I[C]={i:C,l:!1,exports:{}};return g[C].call(A.exports,A,A.exports,e),A.l=!0,A.exports}e.m=g,e.c=I,e.d=function(g,I,C){e.o(g,I)||Object.defineProperty(g,I,{configurable:!1,enumerable:!0,get:C})},e.r=function(g){Object.defineProperty(g,"__esModule",{value:!0})},e.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return e.d(I,"a",I),I},e.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},e.p="",e(e.s=1)}([function(module,exports,__webpack_require__){"use strict";eval("\n/**\n    This module contains a class to represent a Binary Search Tree.\n  It supports both repeated and non repeated elements: you can set this\n  constraint when creating a new tree object.\n    An important thing to know is that the types you want to use in the tree\n  must implement the [[NodeData]] interface. Otherwise, the tree won't\n  work accordingly.\n  @preferred\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n  A node used in the tree.\n  @hidden\n*/\nclass TreeNode {\n    constructor(data) {\n        this.data = data;\n        this.amount = 1;\n        this.left = undefined;\n        this.right = undefined;\n    }\n    /** Checks whether an equals function exists in the object. If it doesnt,\n    tries to use === operator to perform equality check instead. */\n    equals(obj) {\n        if (this.data.equals)\n            return this.data.equals(obj.data);\n        else\n            return this.data === obj.data;\n    }\n    /** Checks whether an greaterThan function exists in the object. If it doesnt,\n    tries to use > operator to check if this.data is greater than obj.data */\n    greaterThan(obj) {\n        if (this.data.greaterThan)\n            return this.data.greaterThan(obj.data);\n        else\n            return this.data > obj.data;\n    }\n}\n/** The Binary Search Tree class. It is a generic class, so it is supposed to\nsupport user defined types. However, in order to the class work properly, it\nis necessary that the given type implements the [[NodeData]] interface. */\nclass BinarySearchTree {\n    /**\n      @param {boolean} repeated true if you want the tree to allow repeated elements. By default it is false.\n    */\n    constructor(repeated = false) {\n        this.root = undefined;\n        this.size = 0;\n        this.repeated = repeated;\n    }\n    /**\n      @returns The amount of elements stored in the tree.\n    */\n    getSize() {\n        return this.size;\n    }\n    /**\n      Clear the tree. It will loose reference to every node that had been stored.\n    */\n    clear() {\n        this.root = undefined;\n        this.size = 0;\n    }\n    /**\n      @param {T} value The value that you want to count in the tree.\n      @returns The number of elements that match that value.\n    */\n    count(value) {\n        let element = this.findRef(value)[0];\n        if (element)\n            return element.amount;\n        else\n            return 0;\n    }\n    /**\n      A generator that yields the elements of the tree in order.\n    */\n    valuesGen() {\n        function* helper(curNode) {\n            if (curNode) {\n                yield* helper(curNode.left);\n                for (let i = 0; i < curNode.amount; ++i)\n                    yield curNode.data;\n                yield* helper(curNode.right);\n            }\n        }\n        return helper(this.root);\n    }\n    /**\n      @returns an array of elements stored in the tree in increasing order. It's\n      done by implementing Morris Inorder Tree Traversal Algorithm.\n    */\n    valuesList() {\n        let values = [];\n        let curNode = this.root;\n        while (curNode) {\n            if (!curNode.left) {\n                for (let i = 0; i < curNode.amount; ++i)\n                    values.push(curNode.data);\n                curNode = curNode.right;\n            }\n            else {\n                let pre = curNode.left;\n                while (pre.right && pre.right !== curNode)\n                    pre = pre.right;\n                if (pre.right == curNode) {\n                    for (let i = 0; i < curNode.amount; ++i)\n                        values.push(curNode.data);\n                    pre.right = undefined;\n                    curNode = curNode.right;\n                }\n                else {\n                    pre.right = curNode;\n                    curNode = curNode.left;\n                }\n            }\n        }\n        return values;\n    }\n    /**\n      @param {T} value The value to be stored in the tree.\n      @returns true if the element was successfully stored, false otherwise.\n    */\n    insert(value) {\n        let newNode = new TreeNode(value);\n        if (!this.root) {\n            this.root = newNode;\n        }\n        else {\n            let currentNode = this.root;\n            while (true) {\n                if (newNode.greaterThan(currentNode)) {\n                    if (currentNode.right)\n                        currentNode = currentNode.right;\n                    else {\n                        currentNode.right = newNode;\n                        break;\n                    }\n                }\n                else if (newNode.equals(currentNode) && this.repeated) {\n                    ++currentNode.amount;\n                    break;\n                }\n                else if (newNode.equals(currentNode) && !this.repeated) {\n                    return false;\n                }\n                else {\n                    if (currentNode.left)\n                        currentNode = currentNode.left;\n                    else {\n                        currentNode.left = newNode;\n                        break;\n                    }\n                }\n            }\n        }\n        ++this.size;\n        return true;\n    }\n    findRef(value) {\n        let seekedValue = new TreeNode(value);\n        let curNode = this.root;\n        let curParent;\n        curParent = undefined;\n        while (curNode) {\n            if (seekedValue.equals(curNode))\n                return [curNode, curParent];\n            else {\n                curParent = curNode;\n                if (seekedValue.greaterThan(curNode))\n                    curNode = curNode.right;\n                else\n                    curNode = curNode.left;\n            }\n        }\n        return [undefined, undefined];\n    }\n    /**\n      @param {T} value The value to be searched.\n      @returns true if the falue was found, false otherwise.\n    */\n    find(value) {\n        let found = this.findRef(value)[0];\n        return found ? true : false;\n    }\n    /**\n      @param {T} value The value to be removed.\n      @returns true if the value was found and removed, false otherwise.\n    */\n    remove(value) {\n        let curNode;\n        let parent;\n        [curNode, parent] = this.findRef(value);\n        if (!curNode && !parent)\n            return false;\n        if (curNode) {\n            if (curNode.amount > 1)\n                --curNode.amount;\n            else if (!curNode.right && !curNode.left) {\n                if (parent) {\n                    if (curNode.greaterThan)\n                        curNode.greaterThan(parent) ? parent.right = undefined : parent.left = undefined;\n                }\n                else\n                    this.root = undefined;\n            }\n            else if (!curNode.left || !curNode.right) {\n                let child = curNode.left || curNode.right;\n                if (parent) {\n                    if (curNode.greaterThan)\n                        curNode.greaterThan(parent) ? parent.right = child : parent.left = child;\n                }\n                else\n                    this.root = child;\n            }\n            else {\n                let candidateParent = curNode;\n                let candidate = curNode.left;\n                while (candidate.right) {\n                    candidateParent = candidate;\n                    candidate = candidate.right;\n                }\n                if (candidate.left)\n                    candidateParent.left = candidate.left;\n                if (curNode.left.equals) {\n                    if (!curNode.left.equals(candidate))\n                        candidate.left = curNode.left;\n                }\n                candidate.right = curNode.right;\n                if (parent)\n                    curNode.greaterThan(parent) ? parent.right = candidate : parent.left = candidate;\n                else\n                    this.root = candidate;\n            }\n            --this.size;\n            return true;\n        }\n        return false;\n    }\n}\nexports.BinarySearchTree = BinarySearchTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9iaW5hcnktc2VhcmNoLXRyZWUvQmluYXJ5U2VhcmNoVHJlZS50cz84Y2E0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAgICBUaGlzIG1vZHVsZSBjb250YWlucyBhIGNsYXNzIHRvIHJlcHJlc2VudCBhIEJpbmFyeSBTZWFyY2ggVHJlZS5cbiAgSXQgc3VwcG9ydHMgYm90aCByZXBlYXRlZCBhbmQgbm9uIHJlcGVhdGVkIGVsZW1lbnRzOiB5b3UgY2FuIHNldCB0aGlzXG4gIGNvbnN0cmFpbnQgd2hlbiBjcmVhdGluZyBhIG5ldyB0cmVlIG9iamVjdC5cbiAgICBBbiBpbXBvcnRhbnQgdGhpbmcgdG8ga25vdyBpcyB0aGF0IHRoZSB0eXBlcyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyZWVcbiAgbXVzdCBpbXBsZW1lbnQgdGhlIFtbTm9kZURhdGFdXSBpbnRlcmZhY2UuIE90aGVyd2lzZSwgdGhlIHRyZWUgd29uJ3RcbiAgd29yayBhY2NvcmRpbmdseS5cbiAgQHByZWZlcnJlZFxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICBBIG5vZGUgdXNlZCBpbiB0aGUgdHJlZS5cbiAgQGhpZGRlblxuKi9cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gMTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgYW4gZXF1YWxzIGZ1bmN0aW9uIGV4aXN0cyBpbiB0aGUgb2JqZWN0LiBJZiBpdCBkb2VzbnQsXG4gICAgdHJpZXMgdG8gdXNlID09PSBvcGVyYXRvciB0byBwZXJmb3JtIGVxdWFsaXR5IGNoZWNrIGluc3RlYWQuICovXG4gICAgZXF1YWxzKG9iaikge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmVxdWFscylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZXF1YWxzKG9iai5kYXRhKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSA9PT0gb2JqLmRhdGE7XG4gICAgfVxuICAgIC8qKiBDaGVja3Mgd2hldGhlciBhbiBncmVhdGVyVGhhbiBmdW5jdGlvbiBleGlzdHMgaW4gdGhlIG9iamVjdC4gSWYgaXQgZG9lc250LFxuICAgIHRyaWVzIHRvIHVzZSA+IG9wZXJhdG9yIHRvIGNoZWNrIGlmIHRoaXMuZGF0YSBpcyBncmVhdGVyIHRoYW4gb2JqLmRhdGEgKi9cbiAgICBncmVhdGVyVGhhbihvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ncmVhdGVyVGhhbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ3JlYXRlclRoYW4ob2JqLmRhdGEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhID4gb2JqLmRhdGE7XG4gICAgfVxufVxuLyoqIFRoZSBCaW5hcnkgU2VhcmNoIFRyZWUgY2xhc3MuIEl0IGlzIGEgZ2VuZXJpYyBjbGFzcywgc28gaXQgaXMgc3VwcG9zZWQgdG9cbnN1cHBvcnQgdXNlciBkZWZpbmVkIHR5cGVzLiBIb3dldmVyLCBpbiBvcmRlciB0byB0aGUgY2xhc3Mgd29yayBwcm9wZXJseSwgaXRcbmlzIG5lY2Vzc2FyeSB0aGF0IHRoZSBnaXZlbiB0eXBlIGltcGxlbWVudHMgdGhlIFtbTm9kZURhdGFdXSBpbnRlcmZhY2UuICovXG5jbGFzcyBCaW5hcnlTZWFyY2hUcmVlIHtcbiAgICAvKipcbiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcmVwZWF0ZWQgdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgdHJlZSB0byBhbGxvdyByZXBlYXRlZCBlbGVtZW50cy4gQnkgZGVmYXVsdCBpdCBpcyBmYWxzZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcGVhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLnJlcGVhdGVkID0gcmVwZWF0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgQHJldHVybnMgVGhlIGFtb3VudCBvZiBlbGVtZW50cyBzdG9yZWQgaW4gdGhlIHRyZWUuXG4gICAgKi9cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgIENsZWFyIHRoZSB0cmVlLiBJdCB3aWxsIGxvb3NlIHJlZmVyZW5jZSB0byBldmVyeSBub2RlIHRoYXQgaGFkIGJlZW4gc3RvcmVkLlxuICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICBAcGFyYW0ge1R9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHlvdSB3YW50IHRvIGNvdW50IGluIHRoZSB0cmVlLlxuICAgICAgQHJldHVybnMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IG1hdGNoIHRoYXQgdmFsdWUuXG4gICAgKi9cbiAgICBjb3VudCh2YWx1ZSkge1xuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuZmluZFJlZih2YWx1ZSlbMF07XG4gICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuYW1vdW50O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICBBIGdlbmVyYXRvciB0aGF0IHlpZWxkcyB0aGUgZWxlbWVudHMgb2YgdGhlIHRyZWUgaW4gb3JkZXIuXG4gICAgKi9cbiAgICB2YWx1ZXNHZW4oKSB7XG4gICAgICAgIGZ1bmN0aW9uKiBoZWxwZXIoY3VyTm9kZSkge1xuICAgICAgICAgICAgaWYgKGN1ck5vZGUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogaGVscGVyKGN1ck5vZGUubGVmdCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJOb2RlLmFtb3VudDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBjdXJOb2RlLmRhdGE7XG4gICAgICAgICAgICAgICAgeWllbGQqIGhlbHBlcihjdXJOb2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgQHJldHVybnMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3RvcmVkIGluIHRoZSB0cmVlIGluIGluY3JlYXNpbmcgb3JkZXIuIEl0J3NcbiAgICAgIGRvbmUgYnkgaW1wbGVtZW50aW5nIE1vcnJpcyBJbm9yZGVyIFRyZWUgVHJhdmVyc2FsIEFsZ29yaXRobS5cbiAgICAqL1xuICAgIHZhbHVlc0xpc3QoKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1ck5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHdoaWxlIChjdXJOb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWN1ck5vZGUubGVmdCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTm9kZS5hbW91bnQ7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goY3VyTm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmUgPSBjdXJOb2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHByZS5yaWdodCAmJiBwcmUucmlnaHQgIT09IGN1ck5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHByZSA9IHByZS5yaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocHJlLnJpZ2h0ID09IGN1ck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJOb2RlLmFtb3VudDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goY3VyTm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZS5yaWdodCA9IGN1ck5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBjdXJOb2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgQHBhcmFtIHtUfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkIGluIHRoZSB0cmVlLlxuICAgICAgQHJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCB3YXMgc3VjY2Vzc2Z1bGx5IHN0b3JlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICovXG4gICAgaW5zZXJ0KHZhbHVlKSB7XG4gICAgICAgIGxldCBuZXdOb2RlID0gbmV3IFRyZWVOb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlLmdyZWF0ZXJUaGFuKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld05vZGUuZXF1YWxzKGN1cnJlbnROb2RlKSAmJiB0aGlzLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICsrY3VycmVudE5vZGUuYW1vdW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3Tm9kZS5lcXVhbHMoY3VycmVudE5vZGUpICYmICF0aGlzLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmxlZnQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5kUmVmKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZWVrZWRWYWx1ZSA9IG5ldyBUcmVlTm9kZSh2YWx1ZSk7XG4gICAgICAgIGxldCBjdXJOb2RlID0gdGhpcy5yb290O1xuICAgICAgICBsZXQgY3VyUGFyZW50O1xuICAgICAgICBjdXJQYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlIChjdXJOb2RlKSB7XG4gICAgICAgICAgICBpZiAoc2Vla2VkVmFsdWUuZXF1YWxzKGN1ck5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBbY3VyTm9kZSwgY3VyUGFyZW50XTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1clBhcmVudCA9IGN1ck5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZWtlZFZhbHVlLmdyZWF0ZXJUaGFuKGN1ck5vZGUpKVxuICAgICAgICAgICAgICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBjdXJOb2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAgQHBhcmFtIHtUfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgc2VhcmNoZWQuXG4gICAgICBAcmV0dXJucyB0cnVlIGlmIHRoZSBmYWx1ZSB3YXMgZm91bmQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAqL1xuICAgIGZpbmQodmFsdWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5maW5kUmVmKHZhbHVlKVswXTtcbiAgICAgICAgcmV0dXJuIGZvdW5kID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgIEBwYXJhbSB7VH0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHJlbW92ZWQuXG4gICAgICBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAqL1xuICAgIHJlbW92ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgY3VyTm9kZTtcbiAgICAgICAgbGV0IHBhcmVudDtcbiAgICAgICAgW2N1ck5vZGUsIHBhcmVudF0gPSB0aGlzLmZpbmRSZWYodmFsdWUpO1xuICAgICAgICBpZiAoIWN1ck5vZGUgJiYgIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN1ck5vZGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJOb2RlLmFtb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgLS1jdXJOb2RlLmFtb3VudDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJOb2RlLnJpZ2h0ICYmICFjdXJOb2RlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJOb2RlLmdyZWF0ZXJUaGFuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyTm9kZS5ncmVhdGVyVGhhbihwYXJlbnQpID8gcGFyZW50LnJpZ2h0ID0gdW5kZWZpbmVkIDogcGFyZW50LmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1ck5vZGUubGVmdCB8fCAhY3VyTm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IGN1ck5vZGUubGVmdCB8fCBjdXJOb2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ck5vZGUuZ3JlYXRlclRoYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJOb2RlLmdyZWF0ZXJUaGFuKHBhcmVudCkgPyBwYXJlbnQucmlnaHQgPSBjaGlsZCA6IHBhcmVudC5sZWZ0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlUGFyZW50ID0gY3VyTm9kZTtcbiAgICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gY3VyTm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChjYW5kaWRhdGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlUGFyZW50ID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUubGVmdClcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlUGFyZW50LmxlZnQgPSBjYW5kaWRhdGUubGVmdDtcbiAgICAgICAgICAgICAgICBpZiAoY3VyTm9kZS5sZWZ0LmVxdWFscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1ck5vZGUubGVmdC5lcXVhbHMoY2FuZGlkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZS5sZWZ0ID0gY3VyTm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUucmlnaHQgPSBjdXJOb2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGN1ck5vZGUuZ3JlYXRlclRoYW4ocGFyZW50KSA/IHBhcmVudC5yaWdodCA9IGNhbmRpZGF0ZSA6IHBhcmVudC5sZWZ0ID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLS10aGlzLnNpemU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5CaW5hcnlTZWFyY2hUcmVlID0gQmluYXJ5U2VhcmNoVHJlZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BinarySearchTree_1 = __webpack_require__(0);\nlet tree = new BinarySearchTree_1.BinarySearchTree();\nlet treeRepr = document.getElementById('treeRepr');\nlet sizeElement = document.getElementById('treeSize');\nfunction refreshScreen() {\n    // Refresh the node counter\n    sizeElement.innerHTML = tree.getSize().toString();\n    // Refresh the tree representation\n    let valuesText = [];\n    for (let value of tree.valuesGen())\n        valuesText.push(value.toString());\n    treeRepr.innerHTML = valuesText.join(' ');\n}\nlet insertButton = document.getElementById('insertButton');\nlet input = document.getElementById('newValueField');\ninsertButton.onclick = function () {\n    tree.insert(parseInt(input.value));\n    refreshScreen();\n};\nlet removeButton = document.getElementById('removeButton');\nremoveButton.onclick = function () {\n    tree.remove(parseInt(input.value));\n    refreshScreen();\n};\nlet clearButton = document.getElementById('clearButton');\nclearButton.onclick = function () {\n    tree.clear();\n    refreshScreen();\n};\nlet searchButton = document.getElementById('searchButton');\nlet otherField = document.getElementById('otherField');\nsearchButton.onclick = function () {\n    let result = tree.find(parseInt(otherField.value));\n    let resultsSpan = document.getElementById('otherResults');\n    let text;\n    text = (result) ? 'Value found' : 'Value not found';\n    resultsSpan.innerHTML = text;\n};\nlet countButton = document.getElementById('countButton');\ncountButton.onclick = function () {\n    let result = tree.count(parseInt(otherField.value));\n    let resultsSpan = document.getElementById('otherResults');\n    resultsSpan.innerHTML = `${result} elements found`;\n};\nrefreshScreen();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9iaW5hcnktc2VhcmNoLXRyZWUvZGVtby9zcmMvaW5kZXgudHM/YjA0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5U2VhcmNoVHJlZV8xID0gcmVxdWlyZShcIi4uLy4uL0JpbmFyeVNlYXJjaFRyZWVcIik7XG5sZXQgdHJlZSA9IG5ldyBCaW5hcnlTZWFyY2hUcmVlXzEuQmluYXJ5U2VhcmNoVHJlZSgpO1xubGV0IHRyZWVSZXByID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyZWVSZXByJyk7XG5sZXQgc2l6ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJlZVNpemUnKTtcbmZ1bmN0aW9uIHJlZnJlc2hTY3JlZW4oKSB7XG4gICAgLy8gUmVmcmVzaCB0aGUgbm9kZSBjb3VudGVyXG4gICAgc2l6ZUVsZW1lbnQuaW5uZXJIVE1MID0gdHJlZS5nZXRTaXplKCkudG9TdHJpbmcoKTtcbiAgICAvLyBSZWZyZXNoIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9uXG4gICAgbGV0IHZhbHVlc1RleHQgPSBbXTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB0cmVlLnZhbHVlc0dlbigpKVxuICAgICAgICB2YWx1ZXNUZXh0LnB1c2godmFsdWUudG9TdHJpbmcoKSk7XG4gICAgdHJlZVJlcHIuaW5uZXJIVE1MID0gdmFsdWVzVGV4dC5qb2luKCcgJyk7XG59XG5sZXQgaW5zZXJ0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luc2VydEJ1dHRvbicpO1xubGV0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25ld1ZhbHVlRmllbGQnKTtcbmluc2VydEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHRyZWUuaW5zZXJ0KHBhcnNlSW50KGlucHV0LnZhbHVlKSk7XG4gICAgcmVmcmVzaFNjcmVlbigpO1xufTtcbmxldCByZW1vdmVCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3ZlQnV0dG9uJyk7XG5yZW1vdmVCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cmVlLnJlbW92ZShwYXJzZUludChpbnB1dC52YWx1ZSkpO1xuICAgIHJlZnJlc2hTY3JlZW4oKTtcbn07XG5sZXQgY2xlYXJCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xlYXJCdXR0b24nKTtcbmNsZWFyQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJlZS5jbGVhcigpO1xuICAgIHJlZnJlc2hTY3JlZW4oKTtcbn07XG5sZXQgc2VhcmNoQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlYXJjaEJ1dHRvbicpO1xubGV0IG90aGVyRmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3RoZXJGaWVsZCcpO1xuc2VhcmNoQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRyZWUuZmluZChwYXJzZUludChvdGhlckZpZWxkLnZhbHVlKSk7XG4gICAgbGV0IHJlc3VsdHNTcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ290aGVyUmVzdWx0cycpO1xuICAgIGxldCB0ZXh0O1xuICAgIHRleHQgPSAocmVzdWx0KSA/ICdWYWx1ZSBmb3VuZCcgOiAnVmFsdWUgbm90IGZvdW5kJztcbiAgICByZXN1bHRzU3Bhbi5pbm5lckhUTUwgPSB0ZXh0O1xufTtcbmxldCBjb3VudEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb3VudEJ1dHRvbicpO1xuY291bnRCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdHJlZS5jb3VudChwYXJzZUludChvdGhlckZpZWxkLnZhbHVlKSk7XG4gICAgbGV0IHJlc3VsdHNTcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ290aGVyUmVzdWx0cycpO1xuICAgIHJlc3VsdHNTcGFuLmlubmVySFRNTCA9IGAke3Jlc3VsdH0gZWxlbWVudHMgZm91bmRgO1xufTtcbnJlZnJlc2hTY3JlZW4oKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")}]);